class SellQuotesController < ApplicationController
  before_filter :authorize, :time_zone_adjust
  skip_before_filter :verify_authenticity_token
  layout "basic"
  # GET /sell_quotes
  # GET /sell_quotes.xml
  def index
    @sell_quotes = SellQuote.all

    respond_to do |format|
      format.html {
        u = User.find(session[:user_id])
        if session[:user_id] == 1 or u.role_ids.include?(9)
          #如果是BOSS或者Admin，则能改全部
          @edit_bussiness = true
        elsif u.role_ids.include?(6)
          #如果是商务，则能改商务相关
          @edit_bussiness = true
        else
          #如果是其它，则都只能看不能改
          @edit_bussiness = false
        end
      }# index.html.erb
      format.xml  { render :xml => @sell_quotes }
    end
  end

  # GET /sell_quotes/1
  # GET /sell_quotes/1.xml
  def show
    @sell_quote = SellQuote.find(params[:id])

    respond_to do |format|
      format.html # show.html.erb
      format.xml  { render :xml => @sell_quote }
    end
  end

  # GET /sell_quotes/new
  # GET /sell_quotes/new.xml
  def new
    @sell_quote = SellQuote.new

    respond_to do |format|
      format.html # new.html.erb
      format.xml  { render :xml => @sell_quote }
    end
  end

  # GET /sell_quotes/1/edit
  def edit
    if params[:id] == "foo"
      #说明其实是新增
      @sell_quote = SellQuote.new
      @sell_quote.quote_type = 1#这样新增只能增普通报价
      if @sell_quote.save
        params[:id] = @sell_quote.id
        #还要其下新增一个报价块，并传值过去
        sell_quote_block = SellQuoteBlock.new
        sell_quote_block.sell_quote_id = @sell_quote.id
        sell_quote_block.save
        #        p sell_quote_block.id
        @sell_quote_block_id = sell_quote_block.id
        #        p @sell_quote_block_id
        render :text => {'str' => 'OK', "number" => @sell_quote.id, "quote_block_id" => @sell_quote_block_id}.to_json
      else
        render :text => {'str' => 'XX'}.to_json
      end
    else
      #说明是编辑
      @sell_quote = SellQuote.find(params[:id])
    end
    #    p params[:quote_block_id]
    #第二遍过来，只能是用params[:quote_block_id]来判断了，正常编辑的没这项，从新增过来的有这项
    if params[:quote_block_id]
      #有，说明其实是新增
      @sell_quote_block_id = params[:quote_block_id]
      @quote_number = SellQuote.next_number
    else
      @quote_number = @sell_quote.quote_number
    end
    if customer_unit = @sell_quote.customer_unit
      @customer_unit_id = customer_unit.id
      @customer_unit_name = customer_unit.name
      @customer_unit_city = customer_unit.city.name
    end
    if customer = @sell_quote.customer
      @customer_id = customer.id
      @customer_name = customer.name
    end
    @quote_type = @sell_quote.quote_type
    @quote_type_txt = $QUOTE_FORMAT[@quote_type.to_i][2..-1] if @quote_type
    if sale = @sell_quote.sponsor
      @sale_id = sale.id
      @sale_name = sale.real_name
    end
    @language = @sell_quote.language
    @language_txt = @sell_quote.language_txt
    @currency = @sell_quote.currency_id
    @currency_txt = (@sell_quote.currency_id == 0 ? "多币种混合":@sell_quote.currency.name) if @sell_quote.currency
    @total_discount = @sell_quote.total_discount
    @fif_currency_id = @sell_quote.fif_currency_id
    @fif = @sell_quote.fif
    @vat = @sell_quote.vat
    @other_cost = @sell_quote.other_cost
    @total = @sell_quote.total#其实这个才是总价？
    if our_company = @sell_quote.our_company
      @our_company_id = our_company.id
      @our_company_name = our_company.shown_name
    end
    @quote_request = @sell_quote.request
    @quote_term = @sell_quote.term
    #    @quote_total = 0#最终价
    #    @sell_quote.sell_quote_blocks.each do |p|
    #      @quote_total += p.discount_to
    #    end
    #以下是从旧报价生成新报价时要用的变量，基本方式带不上的
    @work_task_id = @sell_quote.work_task_id
    @sale_log_id = @sell_quote.sale_log_id
    @sale_user_id = @sell_quote.sale_user_id
    @quote_type = @sell_quote.quote_type
    @flow_status = @sell_quote.flow_status
    @max_custom_tax = get_max_custom_tax(@sell_quote)
  end

  # POST /sell_quotes
  # POST /sell_quotes.xml
  def create
    @sell_quote = SellQuote.new(params[:sell_quote])

    respond_to do |format|
      if @sell_quote.save
        format.html { redirect_to(@sell_quote, :notice => 'Sell quote was successfully created.') }
        format.xml  { render :xml => @sell_quote, :status => :created, :location => @sell_quote }
      else
        format.html { render :action => "new" }
        format.xml  { render :xml => @sell_quote.errors, :status => :unprocessable_entity }
      end
    end
  end

  # PUT /sell_quotes/1
  # PUT /sell_quotes/1.xml
  def update
    @sell_quote = SellQuote.find(params[:id])

    respond_to do |format|
      if @sell_quote.update_attributes(params[:sell_quote])
        format.html { redirect_to(@sell_quote, :notice => 'Sell quote was successfully updated.') }
        format.xml  { head :ok }
      else
        format.html { render :action => "edit" }
        format.xml  { render :xml => @sell_quote.errors, :status => :unprocessable_entity }
      end
    end
  end

  # DELETE /sell_quotes/1
  # DELETE /sell_quotes/1.xml
  def destroy
    @sell_quote = SellQuote.find(params[:id])
    @sell_quote.destroy

    respond_to do |format|
      format.html { redirect_to(sell_quotes_url) }
      format.xml  { head :ok }
    end
  end

  #获取报价项信息以生成表格
  def get_detail
    respond_to do |format|
      format.json {
        detail_list = gen_detail
        render :text => detail_list.to_json
      }
    end
  end

  def gen_detail
    detail_array = []
    sell_quote = SellQuote.find(params[:id])
    case sell_quote.quote_type
    when 1
      if sell_quote.sell_quote_blocks[0].sell_quote_item_ids.size == 0
        #如果此报价下的报价块只有一个(刚刚新建的那个)，而此报价块下又没有报价项的话，说明是新建
        sqb = sell_quote.sell_quote_blocks[0]
        sqb.quantity = 1
        sqb.unit_price_after_discount = 0
        sqb.save
      else
        #标准报价的话，报价块默认只有一个看不到的
        sqb = sell_quote.sell_quote_blocks[0]
        if !(sqb.sell_quote.term.nil?) && sqb.sell_quote.term.split("$$")[42] == "true"
          #当term不为空时，才会有后面的是否勾选“在报价中计算关税”
          #二者都成立的时候，直接读数据库。
          discount_to = sqb.discount_to.to_s
          unit_price = sqb.unit_price.to_s
        else
          #如果根本没term这项(新建的就没有)，那就和没勾“在报价中计算关税”一样(新建同样也不会有这个)计算
          #因为标准报价的报价块不会有折后单价，那么报价块单价 = Σ(报价块下所有报价项折后总价)
          unit_price = 0
          sqb.sell_quote_items.each do |sqi|
            unit_price += sqi.discount_to
          end
          discount_to = (unit_price * sqb.quantity).to_s
          unit_price = unit_price.to_s
        end
        sell_quote_items = sqb.sell_quote_items
        #报价块中的报价项
        sell_quote_items.each_with_index do |sqi, index_i|
          #        discount_to = 0
          #        #如果没有勾“在报价中计算关税”，则报价项折后总价=报价项折后单价乘以数量↓
          #        if sqi.sell_quote_block.sell_quote.term.nil? || sqi.sell_quote_block.sell_quote.term.split("$$")[42] != "true"
          #          discount_to = (sqi.unit_price_after_discount.nil? ? sqi.unit_price : sqi.unit_price_after_discount * sqi.product_quantity).to_s
          #        else
          #          discount_to = sqi.discount_to.to_s
          #        end
          discount_to = sqi.discount_to.to_s#要信任上一步计算，这里不再算
          detail_array << eval("{'hidden_id' => '"+sqi.id.to_s+#本来这里是用id的，结果上下两处的“id”会起冲突……
            "', 'product_model' => '" + sqi.product.model+
              "', 'parameter' => '" + sqi.parameter+
              "', 'quantity' => '" + sqi.product_quantity.to_s+
              "', 'currency' => '" + sqi.product.currency.name+
              "', 'unit_price' => '" + sqi.unit_price.to_s+
              "', 'unit_price_after_discount' => '" + sqi.unit_price_after_discount.to_s +
              "', 'discounted_currency' => '" + ((sqi.discounted_currency_id.nil?)? "待定": sqi.discounted_currency.name)+
              "', 'custom_tax' => '" + sqi.product.custom_tax.to_s+
              "', 'discount_rate' => '" + sqi.discount_rate.to_s+
              "', 'discount_to' => '" + discount_to +
              "', 'is_sys' => '" + pre_add_zero(1,2).to_s+"-"+pre_add_zero(index_i+1,3).to_s +
              "', 'currency_id' => '" + sqi.product.currency.id.to_s+
              "'}")
        end
      end
    when 2
      #单项折扣，报价块也只有一个看不到的
      sqb = sell_quote.sell_quote_blocks[0]
      if !(sqb.sell_quote.term.nil?) && sqb.sell_quote.term.split("$$")[42] == "true"
        #当term不为空时，才会有后面的是否勾选“在报价中计算关税”
        #二者都成立的时候，直接读数据库。
        discount_to = sqb.discount_to.to_s
        unit_price = sqb.unit_price.to_s
      else
        #如果根本没term这项(新建的就没有)，那就和没勾“在报价中计算关税”一样(新建同样也不会有这个)计算
        #因为标准报价的报价块不会有折后单价，那么报价块单价 = Σ(报价块下所有报价项单价 * 数量)
        unit_price = 0
        sqb.sell_quote_items.each do |sqi|
          unit_price += (sqi.unit_price_after_discount.nil? ? sqi.unit_price : sqi.unit_price_after_discount * sqi.product_quantity)
        end
        discount_to = (unit_price * sqb.quantity).to_s
        unit_price = unit_price.to_s
      end
      sell_quote_items = sqb.sell_quote_items
      #报价块中的报价项
      sell_quote_items.each_with_index do |sqi, index_i|
        discount_to = sqi.discount_to.to_s#要信任上一步计算，这里不再算
        detail_array << eval("{'hidden_id' => '"+sqi.id.to_s+#本来这里是用id的，结果上下两处的“id”会起冲突……
          "', 'product_model' => '" + sqi.product.model+
            "', 'parameter' => '" + sqi.parameter+
            "', 'quantity' => '" + sqi.product_quantity.to_s+
            "', 'currency' => '" + sqi.product.currency.name+
            "', 'unit_price' => '" + sqi.unit_price.to_s+
            "', 'unit_price_after_discount' => '" + sqi.unit_price_after_discount.to_s +
            "', 'discounted_currency' => '" + ((sqi.discounted_currency_id.nil?)? "待定": sqi.discounted_currency.name)+
            "', 'custom_tax' => '" + sqi.product.custom_tax.to_s+
            "', 'discount_rate' => '" + sqi.discount_rate.to_s+
            "', 'discount_to' => '" + discount_to +
            "', 'is_sys' => '" + pre_add_zero(1,2).to_s+"-"+pre_add_zero(index_i+1,3).to_s +
            "', 'currency_id' => '" + sqi.product.currency.id.to_s+
            "'}")
      end
    when 3
      #系统报价的话，要看报价块
      sell_quote_blocks = sell_quote.sell_quote_blocks
      sell_quote_blocks.each_with_index do |sqb, index_b|
        if !(sqb.sell_quote.term.nil?) && sqb.sell_quote.term.split("$$")[42] == "true"
          #当term不为空时，才会有后面的是否勾选“在报价中计算关税”
          #二者都成立的时候，直接读数据库。
          discount_to = sqb.discount_to.to_s
          unit_price = sqb.unit_price.to_s
        else
          #如果没有勾“在报价中计算关税”，则再看报价块有没有默认的折后单价
          if sqb.unit_price_after_discount.nil?
            #如果没有，那么报价块单价=计算报价块下所有报价项折后总价之和
            unit_price = 0
            sqb.sell_quote_items.each do |sqi|
              unit_price += sqi.discount_to
            end
            discount_to = (unit_price * sqb.quantity).to_s
            unit_price = unit_price.to_s
          else
            #如果有，那么就用它
            discount_to = (sqb.unit_price_after_discount * sqb.quantity).to_s
            unit_price = sqb.unit_price_after_discount.to_s
          end
        end
        detail_array << eval("{'hidden_id' => '"+sqb.id.to_s+#本来这里是用id的，结果上下两处的“id”会起冲突……
          "', 'product_model' => '" + sqb.description+
            "', 'parameter' => '" + sqb.parameter.to_s+
            "', 'quantity' => '" + sqb.quantity.to_s+
            "', 'currency' => '" + ((sqb.currency.nil? || sqb.currency_id == 0)? "待定": sqb.currency.name)+
            "', 'unit_price' => '" + unit_price+
            "', 'unit_price_after_discount' => '" + sqb.unit_price_after_discount.to_s +
            "', 'discounted_currency' => '" + ((sqb.currency.nil? || sqb.currency_id == 0)? "待定": sqb.currency.name)+
            "', 'custom_tax' => '" + sqb.custom_tax.to_s +
            "', 'discount_rate' => '" + sqb.discount_rate.to_s +
            "', 'discount_to' => '" + discount_to.to_s +
            "', 'is_sys' => '" + pre_add_zero(index_b+1,2).to_s +
            "', 'currency_id' => '" + ((sqb.currency.nil? || sqb.currency_id == 0)? "待定": sqb.currency.id.to_s)+
            "'}")
        sell_quote_items = sqb.sell_quote_items
        #每个报价块中的报价项
        sell_quote_items.each_with_index do |sqi, index_i|
          discount_to = sqi.discount_to.to_s
          detail_array << eval("{'hidden_id' => '"+sqi.id.to_s+#本来这里是用id的，结果上下两处的“id”会起冲突……
            "', 'product_model' => '" + sqi.product.model+
              "', 'parameter' => '" + sqi.parameter+
              "', 'quantity' => '" + sqi.product_quantity.to_s+
              "', 'currency' => '" + sqi.product.currency.name+
              "', 'unit_price' => '" + sqi.unit_price.to_s+
              "', 'unit_price_after_discount' => '" + sqi.unit_price_after_discount.to_s +
              "', 'discounted_currency' => '" + ((sqi.discounted_currency_id.nil?)? "待定": sqi.discounted_currency.name)+
              "', 'custom_tax' => '" + sqi.product.custom_tax.to_s+
              "', 'discount_rate' => '" + sqi.discount_rate.to_s+
              "', 'discount_to' => '" + discount_to.to_s +
              "', 'is_sys' => '" + pre_add_zero(index_b+1,2).to_s+"-"+pre_add_zero(index_i+1,3).to_s +
              "', 'currency_id' => '" + sqi.product.currency.id.to_s+
              "'}")
        end
      end
    when 4
      #阶梯报价，报价块也只有一个看不到的
      sqb = sell_quote.sell_quote_blocks[0]
      if !(sqb.sell_quote.term.nil?) && sqb.sell_quote.term.split("$$")[42] == "true"
        #当term不为空时，才会有后面的是否勾选“在报价中计算关税”
        #二者都成立的时候，直接读数据库。
        discount_to = sqb.discount_to.to_s
        unit_price = sqb.unit_price.to_s
      else
        #如果根本没term这项(新建的就没有)，那就和没勾“在报价中计算关税”一样(新建同样也不会有这个)计算
        #因为标准报价的报价块不会有折后单价，那么报价块单价 = Σ(报价块下所有报价项单价 * 数量)
        unit_price = 0
        sqb.sell_quote_items.each do |sqi|
          unit_price += (sqi.unit_price_after_discount.nil? ? sqi.unit_price : sqi.unit_price_after_discount * sqi.product_quantity)
        end
        discount_to = (unit_price * sqb.quantity).to_s
        unit_price = unit_price.to_s
      end
      sell_quote_items = sqb.sell_quote_items
      #报价块中的报价项
      sell_quote_items.each_with_index do |sqi, index_i|
        discount_to = sqi.discount_to.to_s#要信任上一步计算，这里不再算
        detail_array << eval("{'hidden_id' => '"+sqi.id.to_s+#本来这里是用id的，结果上下两处的“id”会起冲突……
          "', 'product_model' => '" + sqi.product.model+
            "', 'parameter' => '" + sqi.parameter+
            "', 'quantity' => '" + sqi.product_quantity.to_s+"~"+sqi.product_quantity_2.to_s+
            "', 'currency' => '" + sqi.product.currency.name+
            "', 'unit_price' => '" + sqi.unit_price.to_s+
            "', 'unit_price_after_discount' => '" + sqi.unit_price_after_discount.to_s +
            "', 'discounted_currency' => '" + ((sqi.discounted_currency_id.nil?)? "待定": sqi.discounted_currency.name)+
            "', 'custom_tax' => '" + sqi.product.custom_tax.to_s+
            "', 'discount_rate' => '" + sqi.discount_rate.to_s+
            "', 'discount_to' => '" + discount_to +
            "', 'is_sys' => '" + pre_add_zero(1,2).to_s+"-"+pre_add_zero(index_i+1,3).to_s +
            "', 'currency_id' => '" + sqi.product.currency.id.to_s+
            "'}")
      end
    end
    #    for detail in details
    #      detail_array << eval("{'id' => '"+detail.id.to_s+#这个to_s要注意
    #        "', 'text' => '"+detail.id.to_s+"'}")
    #    end
    {"root" => detail_array}
  end

  #以AJAX提交修改报价项时的弹出窗口表单内容
  def submit_quote_item_ajax
    #修改所有币种对应的汇率
    exchange_rate_arr = params[:total_exchange_rate].split(",")
    for currency in Currency.find(:all, :order => "id ASC")
      currency.exchange_rate = exchange_rate_arr[0]
      exchange_rate_arr = exchange_rate_arr[1..-1]
      currency.save
    end
    if params[:id] == "0"
      #0表示新报价项
      sqi = SellQuoteItem.new
      sqi.sell_quote_block_id = params[:sell_quote_block_id].to_i#所属报价块
      sqi.product_id = params[:product_id]#所包含产品
      sqi.currency_id = Product.find(params[:product_id].to_i).currency_id#产品币种
    else
      sqi = SellQuoteItem.find(params[:id])
    end
    sqi.parameter = params[:param].split("$$$").join("\n")#再把特殊字符串改成回车
    sqi.product_quantity = params[:quantity]
    sqi.unit_price = params[:unit_price]
    sqi.unit_price_after_discount = params[:unit_price_after_discount]
    sqi.discounted_currency_id = params[:discounted_currency_id]
    sqi.discount_to = params[:price]
    #这里改了关税的话，产品对应的属性也得改
    product = sqi.product
    product.custom_tax = params[:custom_tax]
    product.save
    #然后报价项的也存一下，因为已经做好的报价关税就不变了
    sqi.custom_tax = params[:custom_tax]
    sqi.save
    unless sqi.sell_quote_block.sell_quote.quote_type == 4
      #只要不是“阶梯报价”，就同时查找本报价中涉及到相同产品的报价项，除本身外全改之
      sqbs = sqi.sell_quote_block.sell_quote.sell_quote_blocks
      sqbs.each_with_index do |sqb, index_b|
        sqis = sqb.sell_quote_items
        sqis.each_with_index do |_sqi, index_i|
          if sqi!=_sqi && _sqi.product_id == sqi.product_id
            _sqi.unit_price = params[:unit_price]
            _sqi.unit_price_after_discount = params[:unit_price_after_discount]
            _sqi.parameter = params[:param]
            _sqi.custom_tax = params[:custom_tax]
            #          if _sqi.discount_to == _sqi.unit_price_after_discount.to_f * _sqi.product_quantity.to_f * (1 + (_sqi.sell_quote_block.sell_quote.has_custom_tax ? _sqi.custom_tax.to_f : 0))
            #            #如果 折后总价 和 折后单价*数量*(1+关税) 相等，说明折后总价是算出来的，而上面改了折后单价/数量/关税之一，所以要重新算
            #            _sqi.discount_to = _sqi.unit_price_after_discount.to_f * _sqi.product_quantity.to_f * (1 + (_sqi.sell_quote_block.sell_quote.has_custom_tax ? _sqi.custom_tax.to_f : 0))
            #          else
            #            #否则说明是之前另外特别打过折的，比如3006算成3000之类，那么不变
            #            _sqi.discount_to = _sqi.discount_to
            #          end
            #          好像以上全是废话，直接不算discount_to就好……
            _sqi.save
          end
        end
      end
    end
    #改变一下参数，再传递给count_whole_table方法计算
    params[:sell_quote_id] = sqi.sell_quote_block.sell_quote.id
    count_whole_table
  end

  #以AJAX提交修改报价块时的弹出窗口表单内容
  def submit_quote_block_ajax
    sqb = SellQuoteBlock.find(params[:id])
    sqb.parameter = params[:param].split("$$$").join("\n")#再把特殊字符串改成回车
    sqb.quantity = params[:quantity]
    sqb.currency_id = params[:currency_id]
    sqb.custom_tax = params[:custom_tax]
    sqb.discount_to = params[:price]
    sqb.unit_price = params[:unit_price]
    sqb.unit_price_after_discount = params[:unit_price_after_discount]
    if sqb.save
      #      表格里的报价块循环求和。因为如果此时再按报价项总和之类的步骤再算一遍，那么就会再次计算出改动之前的结果。
      table_sum = 0
      sell_quote = sqb.sell_quote
      sell_quote.sell_quote_blocks.each do |p|
        table_sum += p.discount_to
      end
      sell_quote.total = (table_sum + (sell_quote.fif||0) - (sell_quote.total_discount||0)) * (1 + (sell_quote.vat||0)) + (sell_quote.other_cost||0)
      if sell_quote.save
        render :text => {"str" => "OK", "table_sum" => sprintf("%.2f",table_sum), "max_custom_tax" => get_max_custom_tax(sell_quote)}.to_json
      end
    end
  end

  #以AJAX提交由报价币种而计算该报价下表格里所有内容
  def count_whole_table
    respond_to do |format|
      format.json {
        if params[:incoming_way] == "quote_currency_droplist" || params[:incoming_way] == "check_custom_tax"
          #专门传过来的特殊值，表示当前操作是“选择报价币种”那个下拉框，此时用params[:id]决定报价
          #又或者当前操作是勾选“是否包含关税”那个复选框，此时也用params[:id]决定报价
          sell_quote = SellQuote.find(params[:id])
        else
          sell_quote = SellQuote.find(params[:sell_quote_id])
        end
        #        puts sell_quote.inspect.gsub(/\"(.*?)\"/,'\1').gsub(/[{}]/, "\n  ").gsub(/[\[\]]/, "\n    ").gsub(/,/, "\n      ")
        if params[:incoming_way] != "add_quote_item_submit" && params[:incoming_way] != "check_custom_tax"
          #专门传过来的特殊值，表示当前操作不是“新增报价项”，才由参数改变报价块的币种
          #也不要是勾选“是否包含关税”那个复选框
          sell_quote.currency_id = params[:sell_quote_currency]
        end
        sell_quote.save
        sell_quote_blocks = sell_quote.sell_quote_blocks
        sell_quote_blocks.each_with_index do |sqb, index_b|
          sell_quote_items = sqb.sell_quote_items
          #每个报价块中的报价项
          sell_quote_block_sum = 0#报价块临时汇总
          sqi_currency_array = []#用于存此报价块下所有报价项币种，以判断是否有重复(是否为单一币种)
          sell_quote_items.each_with_index do |sqi, index_i|
            if params[:sell_quote_currency].to_s == "0"
              #报价币种为“混合”，再看当前报价块下的报价项币种是否一致
              sqi_currency_array << sell_quote_items[index_i].discounted_currency.name
            else
              #报价币种为单一币种时才这样算
              if params[:incoming_way] != "add_quote_item_submit" && params[:incoming_way] != "drag_quote_item" && params[:incoming_way] != "check_custom_tax"
                #专门传过来的特殊值，表示当前操作不是“新增报价项”，才由参数改变报价块的币种
                #拖曳和勾选“是否包含关税”时也不改变报价块的币种
                sqi.discounted_currency_id = params[:sell_quote_currency]
              end
              if params[:incoming_way] == "quote_item_submit"
                #                p params.inspect
                #表示当前操作是“修改报价项”，此时因为报价项内容刚刚被修改过，所以用params里的值来保存当前id的报价项，别的不管
                if sqi.id == params[:id].to_i
                  sqi.unit_price_after_discount = params[:unit_price_after_discount]
                  sqi.discount_to = params[:price]
                end
              elsif params[:incoming_way] == "quote_currency_droplist"
                #专门传过来的特殊值，表示当前操作是“选择报价币种”那个下拉框，此时用当前表格中的值算出新的报价项折后价格，否则不管
                sqi.unit_price_after_discount = sqi.unit_price * sqi.product.currency.exchange_rate / Currency.find(params[:sell_quote_currency].to_i).exchange_rate
                sqi.discount_to = sqi.unit_price_after_discount * sqi.product_quantity * (1 + (sqi.product.custom_tax.blank? ? 0 : sqi.product.custom_tax))
              elsif params[:incoming_way] == "check_custom_tax"
                #表示当前操作是勾选“是否包含关税”那个复选框，此时也用当前表格中的值算出新的报价项折后价格，但由传来的参数决定计不计算关税
                #这个params里没有sell_quote_currency，所以用id来推算
                #                p sell_quote.currency.exchange_rate.to_f
                #                sqi.unit_price_after_discount = sqi.unit_price * sqi.product.currency.exchange_rate / sell_quote.currency.exchange_rate
                #好奇怪，当时为什么要这么算……
                custom_tax = 0
                if params[:count_with_custom_tax] == "true" && !(sqi.product.custom_tax.blank?)
                  custom_tax = sqi.product.custom_tax
                end
                #                p sqi.unit_price_after_discount
                #                p "__________________"
                sqi.discount_to = sqi.unit_price_after_discount * sqi.product_quantity * (1 + custom_tax)
              end
              sqi.save
              #顺便计算一下报价块里所含报价项的合计
              sell_quote_block_sum += sqi.discount_to
            end
          end
          if sqi_currency_array.uniq.size == 1 || params[:sell_quote_currency].to_s != "0"
            #说明报价块中所有报价项都是同一币种，或者本来就是选的单币种报价，则报价块的币种即为此币种
            #            p sqb.inspect
            sqb.currency = sqb.sell_quote_items[0].discounted_currency if sqb.sell_quote_items.size > 0
            #看报价块本身有无关税
            #            p sqb.unit_price_after_discount.to_f
            if sqb.custom_tax.nil? || (!sqb.sell_quote.term.nil? && sqb.sell_quote.term[42] != "true")
              #如果报价块本身无关税，则其单价为其下报价项折后总价之和
              sell_quote_block_sum = 0
              sell_quote_items = sqb.sell_quote_items
              sell_quote_items.each do |sqi|
                sell_quote_block_sum += sqi.discount_to
              end
              sqb.unit_price = sell_quote_block_sum
              sqb.discount_to = ((sqb.unit_price_after_discount.nil? || sqb.unit_price_after_discount == 0) ? sell_quote_block_sum : sqb.unit_price_after_discount) * sqb.quantity

            else
              #否则其单价为其下报价项折前总价之和，再乘以关税
              sell_quote_block_sum = 0
              sell_quote_items = sqb.sell_quote_items
              sell_quote_items.each do |sqi|
                sell_quote_block_sum += sqi.unit_price_after_discount * sqi.product_quantity
              end
              sqb.unit_price = sell_quote_block_sum
              sqb.discount_to = ((sqb.unit_price_after_discount.nil? || sqb.unit_price_after_discount == 0) ? sell_quote_block_sum : sqb.unit_price_after_discount) * sqb.quantity * (1 + sqb.custom_tax)
            end

            #            _sqb.unit_price = sell_quote_sum
            #            #如果有报价块的折后单价，则先将此单价币种兑换，存为新的折后单价，然后用此单价来算折后总价；如果没有，则用直接折前的单价来算“折后”总价
            #            if _sqb.unit_price_after_discount.blank?
            #              price = _sqb.unit_price
            #            else
            #              price = _sqb.unit_price_after_discount * _sqb.currency.exchange_rate / Currency.find(params[:sell_quote_currency].to_i).exchange_rate
            #              _sqb.unit_price_after_discount = price
            #            end
            #            sell_quote_sum = price * _sqb.quantity
            #            _sqb.discount_to = sell_quote_sum * (1 + (_sqb.custom_tax.blank? ? 0 : _sqb.custom_tax))
            #            if params[:incoming_way] != "add_quote_item_submit" && params[:incoming_way] != "drag_quote_item"
            #              #专门传过来的特殊值，表示当前操作不是“新增报价项”，才由参数改变报价块的币种
            #              #拖曳时也不改变报价块的币种
            #              _sqb.currency_id = params[:sell_quote_currency]#这条写早了的话，单价就不会换算了，因为两次的汇率取成了一样的
            #            end
          else
            #说明有多于一种币种，把报价块的币种改成“混合”、合计改成nil
            sqb.currency_id = 0
            sqb.unit_price = nil
            sqb.discount_to = nil
          end
          sqb.save
        end
        #如果当前操作是勾选“是否包含关税”那个复选框，则还要把term里的值改过来
        if params[:incoming_way] == "check_custom_tax"
          term_array = sell_quote.term.nil? ? [] : sell_quote.term.split("$$")#新建的时候term为nil的
          term_array[42] = params[:count_with_custom_tax]
          sell_quote.term = term_array.join("$$")
        end
        #        表格里累加出来的值
        table_sum = 0
        if sell_quote.currency_id == 0
          #报价币种为“混合”的时候，总价算成nil
          sell_quote.total = nil
        else
          #只有报价币种不为“混合”的时候才计算
          sell_quote.sell_quote_blocks.each do |p|
            table_sum += p.discount_to
          end
          sell_quote.total = (table_sum + (sell_quote.fif||0) - (sell_quote.total_discount||0)) * (1 + (sell_quote.vat||0)) + (sell_quote.other_cost||0)
        end
        if sell_quote.save
          render :text => {"str" => "OK", "table_sum" => sprintf("%.2f",table_sum), "max_custom_tax" => get_max_custom_tax(sell_quote)}.to_json
        end
      }
    end
  end

  #根据各种拖动完后的is_sys来重新设定报价块、报价项的id(顺着排的话实在太浪费了)
  def adjust_order_ajax
    sell_quote = SellQuote.find(params[:id])
    #    传过来的参数转成数组，也就是想要排列成这样的报价块、报价项分布关系，形如["B8", "I8", "I9", "B9", "I10", "I30", "B7", "I31", "I20"]，乱序：
    is_sys_arr = params[:is_sys_str].split("$$")
    #    数据库中已经保存好的报价块顺序，形如[7,8,9]这样子，顺序：
    sqbs = SellQuoteBlock.find(:all, :order => "id ASC", :conditions => ["sell_quote_id = ?", params[:id]])
    old_sqb_id_arr = sqbs.map{|p| p.id}
    #    数据库中已经保存好的属于以上报价块的报价项的顺序，形如[8, 9, 10, 20, 30, 31]，顺序：
    sqis = []
    sqbs.each do |sqb|
      sqis += SellQuoteItem.find(:all, :order => "id ASC", :conditions => ["sell_quote_block_id = ?", sqb.id])
    end
    old_sqi_id_arr=sqis.map{|p| p.id}
    #    想排列成这样的报价块架构
    is_sys_arr_sqb = is_sys_arr.select{|e| e.index("B") == 0}
    is_sys_arr_sqi = is_sys_arr.select{|e| e.index("I") == 0}

    #    先构造两个数组备用，一个存报价块，一个存报价项
    temp_sqb_array = []
    temp_sqi_array = []
    temp_sqb_point = 0
    temp_sqi_point = 0
    #    先按总结构来循环
    for i in is_sys_arr
      if i.index("B") == 0
        #说明是报价块，那么new一个新报价块存进报价块数组
        new_sell_quote_block = SellQuoteBlock.find(is_sys_arr_sqb[temp_sqb_point][1..-1].to_i)
        temp_sqb_array << new_sell_quote_block
        temp_sqb_point += 1
      else
        #说明是报价项，那么new一个新报价项存进报价项数组
        new_sell_quote_item = SellQuoteItem.find(is_sys_arr_sqi[temp_sqi_point][1..-1].to_i)
        temp_sqi_array << new_sell_quote_item
        temp_sqi_point += 1
      end
    end
    #    再循环一遍，以确定报价块、报价项的顺序，以及哪个报价项归于哪个报价块下
    for i2 in is_sys_arr
      if i2.index("B") == 0
        #说明是报价块，将报价块数组中第一项id改成old_sqb_id_arr中的第一项，并把此值记下，以备下面报价项用
        SellQuoteBlock.find(old_sqb_id_arr[0]).update_attributes(temp_sqb_array[0].attributes)
        temp_id = temp_sqb_array[0].id
        #然后把此项从两个数组中都去掉
        temp_sqb_array = temp_sqb_array[1..-1]
        old_sqb_id_arr = old_sqb_id_arr[1..-1]
      else
        #说明是报价项，将报价项数组中第一项id改成old_sqi_id_arr中的第一项，并设定其id为上面记下的id
        temp_sqi_array[0].id = old_sqi_id_arr[0]
        if sell_quote.quote_type == 3
          #只有“系统报价”时，才会有“上面记下”的id
          temp_sqi_array[0].sell_quote_block_id = temp_id
        else
          #别的情况下，一个报价只有一个报价块，所以直接取它的id即可
          temp_sqi_array[0].sell_quote_block_id = sell_quote.sell_quote_blocks[0].id
        end
        SellQuoteItem.find(old_sqi_id_arr[0]).update_attributes(temp_sqi_array[0].attributes)
        #然后把此项从两个数组中都去掉
        temp_sqi_array = temp_sqi_array[1..-1]
        old_sqi_id_arr = old_sqi_id_arr[1..-1]
      end
    end
    params[:sell_quote_currency] = SellQuote.find(params[:id]).currency_id.to_s
    params[:sell_quote_id] = params[:id]
    count_whole_table
  end

  #根据传来的参数保存对应的值到数据库中
  def update_sell_quote_ajax
    sell_quote = SellQuote.find(params[:id])
    case params[:item]
    when "total_discount_and_total"
      sell_quote.total_discount = params[:total_discount]
      sell_quote.total = params[:total]
    when "fif_and_total"
      sell_quote.fif = params[:fif]
      sell_quote.total = params[:total]
    end
    if sell_quote.save
      render :text => {"str" => "OK"}
    end
  end

  #删除报价项
  def remove_sell_quote_item_ajax
    for i in params[:to_be_deleted_id].split("$$")
      SellQuoteItem.find(i.to_i).destroy
    end
    params[:sell_quote_id] = params[:id]
    params[:sell_quote_currency] = SellQuote.find(params[:id]).currency_id
    count_whole_table
  end

  #把参数中传来的东东转成指定格式文本存入term，同时生成PDF也写这里了，太长，懒得挑了
  def encode_term_and_save_ajax
    pdf_font = "public/fonts/yahei_mono.ttf"
    old_sell_quote = SellQuote.find(params[:id])
    if params[:quote_number]
      #传过来有值说明是覆盖报价，用传来的id值
      sell_quote = old_sell_quote
    else
      #没传来值说明是空，new一个新报价
      sell_quote = SellQuote.new
    end

    price_type_array = %w(到岸价 离岸价 出厂价 完税后交货 未完税交货)
    price_type_array_en = %w(CIF FOB Ex-works DDP DDU)
    pay_time_array = pay_time_array_en = %w(7 10 15 30 60 90 180)
    pay_way_array = %w(信用证(L/C) 电汇(T/T))
    pay_way_array_en = %w(L/C T/T)
    pay_unit_array = pay_unit_array_en = ["%"] + Currency.find(:all).map{|p| p.name}
    cad_left_via_array = %w(验收合格后凭验收报告议付 凭其余发货单据议付)
    cad_left_via_array_en = ["the Certificate of Acceptance", "the rest shipping documents"]
    receipt_array = %w(不含税，如需开具发票则需另收相应发票税 含普通发票税 含增值税发票税)
    delivery_point_array = %w(收到预付款后 签订合同后 收到信用证后)
    delivery_point_array_en = ["after receipt of the payment", "after signing the contract", "after receipt of the L/C"]#我恨空格
    deliver_time_unit_array = %w(周 个月)
    deliver_time_unit_array_en = %w(week(s) month(s))
    warranty_point_array = %w(发货后 到货后 验收后)
    warranty_point_array_en = ["after shipping out the goods", "after the goods arrival at the destination", "after the acceptance"]
    warranty_time_array = warranty_time_array_en = %w(12 13 24 36)

    ############################################################################
    #    自定义存储时的顺序
    #    city_of_term(city_id)          price_type_of_term(1,price_type_array)
    #    pay_time1(3,pay_time_array)   pay_way1(1,pay_way_array)    pay_count1(100)    pay_unit1(1,pay_unit_array)
    #      cad_count(90)      cad_unit(1,pay_unit_array)        cad_left_count(10)      cad_left_unit(1,pay_unit_array)     cad_left_via(1,cad_left_via_array_en)
    #    pay_time2(3,pay_time_array)   pay_count2(100)    pay_unit2(1,pay_unit_array)
    #      pay_time3(3,pay_time_array)   pay_count3(100)    pay_unit3(1,pay_unit_array)
    #    pay_time4(3,pay_time_array)   pay_count4(100)    pay_unit4(1,pay_unit_array)
    #      pay_count5(100)        pay_unit5(1,pay_unit_array)
    #    is_include_tax(true/false)    receipt(1,receipt_array)
    #    is_delivery(true/false)       delivery_point(1,delivery_point_array)   deliver_time_from(12)   deliver_time_to(24)   deliver_time_unit(1,deliver_time_unit_array)
    #      fes_xmas(true/false)   fes_newy(true/false)    fes_sprg(true/false)
    #    is_warranty(true/false)       warranty_point(1,warranty_point_array)   warranty_time(1,warranty_time_array)    extra_warranty(还有啥奇怪的质保条款都写过来吧，注意中英文。没有就空着)
    #    is_special_discount(true/false)    is_discount_limit(true/false)
    #    valid_time(20100630)
    #    extra_term(请输入自定义条款)
    ############################################################################
    term = []#用$$当分隔符
    if params[:quote_number]
      #传过来有值说明是覆盖报价，用传来的id值
      term << sell_quote.customer_unit.city.id#0
      #      sell_quote.sale_log_id = params[:sale_log_id]
    else
      #如果传了这个值，说明是新报价，那么取客户单位和城市什么的
      sell_quote.customer_unit_id = params[:customer_unit_id]
      sell_quote.customer_id = params[:customer_id]
      sell_quote.work_task_id = params[:work_task_id]
      sell_quote.sale_user_id = params[:sale_user_id]
      sell_quote.quote_type = params[:quote_type]
      sell_quote.flow_status = params[:flow_status]
      #同时也要new一条sale_log
      old_log = old_sell_quote.sale_log
      new_log = SaleLog.new(old_log.attributes)
      new_log.contact_time = DateTime.now#联系时间不能照抄，要更新一下，决定在列表里排序
      new_log.save
      sell_quote.sale_log_id = new_log.id
      city = sell_quote.customer_unit.city
      term << city.id                         #0
      #复制旧报价下的报价块&报价项给新报价
      old_sell_quote = SellQuote.find(params[:current_sell_quote_id])
      old_sell_quote_blocks = old_sell_quote.sell_quote_blocks
      for old_sqb in old_sell_quote_blocks
        new_sqb = SellQuoteBlock.new(old_sqb.attributes)
        new_sqb.sell_quote = sell_quote
        new_sqb.save
        old_sell_quote_items = old_sqb.sell_quote_items
        for old_sqi in old_sell_quote_items
          new_sqi = SellQuoteItem.new(old_sqi.attributes)
          new_sqi.sell_quote_block = new_sqb
          new_sqi.save
        end
      end
    end
    term << params[:price_type_of_term]
    term << params[:pay_time1]                #2
    term << params[:pay_way1]
    term << params[:pay_count1]               #4
    term << params[:pay_unit1]
    term << params[:cad_count]                #6
    term << params[:cad_unit]
    term << params[:cad_left_count]           #8
    term << params[:cad_left_unit]
    term << params[:cad_left_via]             #10
    term << params[:pay_time2]
    term << params[:pay_count2]               #12
    term << params[:pay_unit2]
    term << params[:pay_time3]                #14
    term << params[:pay_count3]
    term << params[:pay_unit3]                #16
    term << params[:pay_time4]
    term << params[:pay_count4]               #18
    term << params[:pay_unit4]
    term << params[:pay_count5]               #20
    term << params[:pay_unit5]
    term << params[:is_include_tax]           #22
    term << params[:receipt]
    term << params[:is_delivery]              #24
    term << params[:delivery_point]
    if params[:deliver_time_from].to_i < params[:deliver_time_to].to_i
      term << params[:deliver_time_from]      #26
      term << params[:deliver_time_to]
    else
      term << params[:deliver_time_to]        #26
      term << params[:deliver_time_from]
    end
    term << params[:deliver_time_unit]        #28
    term << params[:fes_xmas]
    term << params[:fes_newy]                 #30
    term << params[:fes_sprg]
    term << params[:is_warranty]              #32
    term << params[:warranty_point]
    term << params[:warranty_time]            #34
    term << params[:extra_warranty]
    term << params[:is_special_discount]      #36
    term << params[:is_discount_limit]
    term << params[:valid_time]#.strftime("%Y-%m-%d")   #38
    term << params[:extra_term]
    term << params[:is_discount_detail]       #40
    term << params[:is_include_vat]
    term << params[:is_include_customer_tax]  #42
    sell_quote.term =  term.join("$$")
    #报价时间
    sell_quote.created_at = Time.now
    #报价编号
    if params[:quote_number]
      #传过来有值说明是覆盖报价，就用这个值
      sell_quote.quote_number = params[:quote_number]
    else
      #没传来值说明是空，生成一个新值
      sell_quote.quote_number = SellQuote.next_number
    end
    #报价语种
    sell_quote.language = params[:quote_language]
    #报价币种
    sell_quote.currency_id = params[:quote_currency]
    #运保费币种和运保费
    sell_quote.fif_currency_id = params[:fif_currency_id]
    sell_quote.fif = params[:fif]
    #总折扣
    sell_quote.total_discount = params[:total_discount]
    #到货价(即最终价)
    sell_quote.total = params[:total]
    #折合人民币，如果报价币种为“混合”则分开折，如果为单币种则一起折
    #    rmb = 0
    #    if sell_quote.currency_id == 0
    #      for sqb in sell_quote.sell_quote_blocks
    #
    #      end
    #    else
    #
    #    end

    #增值税
    sell_quote.vat = params[:vat]
    #其它费用
    sell_quote.other_cost = params[:other_cost]
    #以哪个公司
    sell_quote.our_company_id = params[:our_company]
    #总价
    sell_quote.total = params[:total]
    #报价的处理人为当前用户
    sell_quote.business_user_id = session[:user_id]
    if sell_quote.save
      #根据这些条款来生成PDF
      require "prawn"
      Prawn::Document.generate("public/files/quotation/#{sell_quote.quote_number}.pdf", :margin => [20, 20]) do
        font pdf_font, :size => 11

        #先是左上角客户方信息
        if sell_quote.language == 1
          customer_info =  "单位：" + sell_quote.customer_unit.name + "\n"
          customer_info += "收件人：" + sell_quote.customer.name + "\n"
          customer_info += "电话：" + ((sell_quote.customer.phone.blank?)? "" : sell_quote.customer.phone.split(",")[0]) + "\n"
          customer_info += "传真：" + ((sell_quote.customer.fax.blank?)? "" : sell_quote.customer.fax)
        else
          customer_info =  "To: " + sell_quote.customer_unit.en_name + "\n"
          customer_info += "Attn: " + ((sell_quote.customer.en_name.blank?)? sell_quote.customer.name : sell_quote.customer.en_name) + "\n"
          customer_info += "Tel: " + ((sell_quote.customer.phone.blank?)? "" : sell_quote.customer.phone.split(",")[0]) + "\n"
          customer_info += "Fax: " + ((sell_quote.customer.fax.blank?)? "" : sell_quote.customer.fax) + "\n"
          customer_info += "Cell: " + ((sell_quote.customer.mobile.blank?)? "" : sell_quote.customer.mobile.split(",")[0])
        end
        bounding_box [0, 750], :width => 220 do
          text customer_info, :leading => 4
        end

        #再是右上角我们公司的信息
        if sell_quote.language == 1
          our_company = "来自：" + sell_quote.our_company.name + "\n"
          our_company += "地址：" + sell_quote.our_company.addr + "\n"
          our_company += "电话：" + sell_quote.our_company.phone + "\n"
          our_company += "传真：" + sell_quote.our_company.fax || ""
        else
          our_company = "From: " + sell_quote.our_company.en_name + "\n"
          our_company += "Addr: " + sell_quote.our_company.en_addr + "\n"
          our_company += "Tel: " + sell_quote.our_company.phone + "\n"
          our_company += "Fax: " + sell_quote.our_company.fax || ""
        end
        bounding_box [340, 750], :width => 220 do
          text our_company, :leading => 4
        end

        #标题
        move_down 20
        text ((sell_quote.language == 1) ? "报价单" : "QUOTATION"), :align => :center, :size => 25.5

        #右边报价编号和日期信息
        info = []
        if sell_quote.language == 1
          info << ["", "编号："+sell_quote.quote_number]
          info << ["", "日期："+sell_quote.created_at.strftime("%Y年%m月%d日")]
        else
          info << ["", "Number: "+sell_quote.quote_number]
          info << ["", "Date: "+sell_quote.created_at.strftime("%d-%b-%y")]
        end
        #          bounding_box [440, 620], :width => 220 do
        #            text info, :leading => 4
        #          end
        #
        table(info,
          :column_widths => {0 => 500, 1 => 180},
          :cell_style => {:padding => 3}
        ) do |t|
          t.cells.style do |cell|
            cell.borders -= [:left, :right, :top, :bottom]#非要这样写才行，而不能直接写=[]
          end
        end

        move_down 5
        text ((sell_quote.language == 1) ? "根据您的需求，我们特提供报价如下：" : "Regarding to your request, we are pleasure inform you as follows: ")

        move_down 5
        #          不用对齐了，不算这块
        #          if sell_quote.currency_id != 0
        #            #币种不为“混合”时，有报价总价，而且总价的位数是最长的
        #            max_length = sprintf("%.2f",sell_quote.total).to_s.size
        #          else
        #            #币种为“混合”时，只能对报价项循环，看哪个总价最长
        #            quote_item_array = SellQuoteItem.find(:all, :conditions => ["sell_quote_block_id = 1 or sell_quote_id = 16"], :include => [:sell_quote_block])
        #            #如果是带关税计算，则以discount_to来比较，如果不是，则以单价*数量来比较
        #            if sell_quote.has_custom_tax
        #              target_array = quote_item_array.map{|p| p.discount_to}
        #            else
        #              target_array = quote_item_array.map{|p| p.unit_price_after_discount * p.product_quantity}
        #            end
        #          end
        font(pdf_font, :size => 8) do
          #上面的各项细节列表
          sell_quote_table = []
          sell_quote_blocks = sell_quote.sell_quote_blocks

          if sell_quote.quote_type == 4
            #如果报价类型是“阶梯报价”，则只显示折后单价(币种换算)
            #先对报价块信息循环
            sell_quote_blocks.each_with_index do |sqb, index_b|
              if sqb.sell_quote.currency_id == 0 && sqb.currency_id == 0
                #如果报价本身的币种是“混合”，报价块的币种也是“混合”，那么单价就不写
                unit_price = ""
                discount_to = ""
              else
                #否则说明此报价块下的报价项币种统一，那么还是写上一个单价
                unit_price = sqb.currency.name.to_s + sprintf("%.2f",sqb.unit_price)
                discount_to = sqb.currency.name.to_s + sprintf("%.2f",sqb.discount_to)
              end
              #对报价项信息循环
              sell_quote_items = sqb.sell_quote_items
              sell_quote_items.each_with_index do |sqi, index_i|
                #每一个把对应信息提取出来写到表格数组里
                sell_quote_table << [(index_b+1).to_s+"-"+(index_i+1).to_s, sqi.product.model.to_s, sqi.parameter, sqi.product_quantity.to_s+"~"+sqi.product_quantity_2.to_s, sqi.discounted_currency.nil? ? "--" : (sqi.discounted_currency.name.to_s + sprintf("%.2f",sqi.unit_price_after_discount))]
              end
            end
            if sell_quote.language == 1
              header = %w(项目 型号 参数 数量 单价)
            else
              header = %w(Item Model Parameter Qty)
              header << "Unit Price"
            end
            table([header]+sell_quote_table,
              :cell_style => {:inline_format => true },
              :header => true,
              :column_widths => {0 => 50, 1 => 100, 2 => 260, 3 => 50, 4 => 100}
            ) do |t|
              t.column(0).style :align => :left
              t.column(3).style :align => :center
              t.column(4).style :align => :right, :font => pdf_font
              t.row(0).style :background_color => 'AAAAAA', :text_color => 'FFFFFF', :align => :center, :size => 11, :font => pdf_font
              0.upto(sell_quote_table.length-1) do |i|#这个长度关系……+1和-1
                t.rows(i+1).columns(0..4).background_color = ((sell_quote_table[i][0].index("-").nil?) ? "EEEEEE" : "FFFFFF")
              end
            end
          else
            if term[40] == "false"
              #如果没有选“显示明细”，显示的东西少一些
              #先对报价块信息循环
              sell_quote_blocks.each_with_index do |sqb, index_b|
                #                p sqb
                if sqb.sell_quote.currency_id == 0 && sqb.currency_id == 0
                  #如果报价本身的币种是“混合”，报价块的币种也是“混合”，那么单价就不写
                  unit_price = ""
                  discount_to = ""
                else
                  #否则说明此报价块下的报价项币种统一，那么还是写上一个单价
                  unit_price = sqb.currency.name.to_s + sprintf("%.2f",sqb.unit_price_after_discount.blank? ? sqb.unit_price : sqb.unit_price_after_discount)
                  #好像新增一个标准报价的时候unit_price_after_discount是空的，所以判断一下
                  discount_to = sqb.currency.name.to_s + sprintf("%.2f",sqb.discount_to)
                end
                #每一个把对应信息提取出来写到表格数组里
                if sell_quote.quote_type == 3
                  #系统报价的时候才写报价块，别的情况不能写，写了居然会因为带有nil而不执行
                  sell_quote_table << [(index_b+1).to_s, sqb.description, sqb.parameter, sqb.quantity.to_s, unit_price, discount_to]
                end
                #再对报价项信息循环
                sell_quote_items = sqb.sell_quote_items
                sell_quote_items.each_with_index do |sqi, index_i|
                  #也每一个把对应信息提取出来写到表格数组里
                  sell_quote_table << [(index_b+1).to_s+"-"+(index_i+1).to_s, sqi.product.model.to_s, sqi.parameter, sqi.product_quantity.to_s, sqi.currency.name.to_s + sprintf("%.2f",sqi.unit_price), sqi.discounted_currency.nil? ? "--" : (sqi.discounted_currency.name.to_s + sprintf("%.2f",sqi.discount_to))]
                end
              end
              if sell_quote.language == 1
                header = %w(项目 型号 参数 数量 单价 小计)
              else
                header = %w(Item Model Parameter Qty)
                header << "Unit Price"
                header << "Sub-total"
              end
              table([header]+sell_quote_table,
                :cell_style => {:inline_format => true },
                :header => true,
                :column_widths => {0 => 50, 1 => 100, 2 => 260, 3 => 50, 4 => 100, 5 => 120 }
              ) do |t|
                t.column(0).style :align => :left
                t.column(3).style :align => :center
                t.column(4..5).style :align => :right, :font => pdf_font
                t.row(0).style :background_color => 'AAAAAA', :text_color => 'FFFFFF', :align => :center, :size => 11, :font => pdf_font
                0.upto(sell_quote_table.length-1) do |i|#这个长度关系……+1和-1
                  t.rows(i+1).columns(0..5).background_color = ((sell_quote_table[i][0].index("-").nil?) ? "EEEEEE" : "FFFFFF")
                end
              end
            else
              #选了“显示明细”，显示的东西多一些
              #先对报价块信息循环
              sell_quote_blocks.each_with_index do |sqb, index_b|
                if sqb.sell_quote.currency_id == 0 && sqb.currency_id == 0
                  #如果报价本身的币种是“混合”，报价块的币种也是“混合”，那么单价就不写
                  unit_price = ""
                  unit_price_after_discount = ""
                  discount_to = ""
                else
                  #否则说明此报价块下的报价项币种统一，那么还是写上一个单价
                  unit_price = sqb.currency.name.to_s + sprintf("%.2f",sqb.unit_price)
                  if sqb.unit_price_after_discount.nil?
                    unit_price_after_discount = unit_price
                  else
                    unit_price_after_discount = sqb.currency.name.to_s + sprintf("%.2f",sqb.unit_price_after_discount)
                  end
                  discount_to = sqb.currency.name.to_s + sprintf("%.2f",sqb.discount_to)
                end
                #每一个把对应信息提取出来写到表格数组里
                if sell_quote.quote_type == 3
                  #系统报价的时候才写报价块，别的情况不能写，写了居然会因为带有nil而不执行
                  sell_quote_table << [(index_b+1).to_s, sqb.description, sqb.parameter, sqb.quantity.to_s, unit_price, unit_price_after_discount, discount_to]
                end
                #再对报价项信息循环
                sell_quote_items = sqb.sell_quote_items
                sell_quote_items.each_with_index do |sqi, index_i|
                  #也每一个把对应信息提取出来写到表格数组里
                  sell_quote_table << [(index_b+1).to_s+"-"+(index_i+1).to_s, sqi.product.model.to_s, sqi.parameter, sqi.product_quantity.to_s, sqi.currency.name.to_s + sprintf("%.2f",sqi.unit_price), sqi.discounted_currency.name.to_s + sprintf("%.2f",sqi.unit_price_after_discount), sqi.discounted_currency.nil? ? "--" : (sqi.discounted_currency.name.to_s + sprintf("%.2f",sqi.discount_to))]
                end
              end
              if sell_quote.language == 1
                header = %w(项目 型号 参数 数量 折前单价 折后单价 折后总价(含税))
              else
                header = %w(Item Model Parameter Qty)
                header << "Unit Price before Discount"
                header << "Unit Price after Discount"
                header << "Sub-total"
              end
              table([header]+sell_quote_table,
                :cell_style => {:inline_format => true },
                :header => true,
                :column_widths => {0 => 50, 1 => 100, 2 => 260, 3 => 50, 4 => 100, 5 => 100, 6 => 120 }
              ) do |t|
                t.column(0).style :align => :left
                t.column(3).style :align => :center
                t.column(4..6).style :align => :right, :font => pdf_font
                t.row(0).style :background_color => 'AAAAAA', :text_color => 'FFFFFF', :align => :center, :size => 11, :font => pdf_font
                0.upto(sell_quote_table.length-1) do |i|#这个长度关系……+1和-1
                  t.rows(i+1).columns(0..6).background_color = ((sell_quote_table[i][0].index("-").nil?) ? "EEEEEE" : "FFFFFF")
                end
              end
            end
          end
          #下面的合计表，没办法colspan，只能这样子了，注意第0栏的宽度应该比上面那些的宽度加起来略大一点(可能是表格边线宽度)
          if sell_quote.currency_id != 0
            #币种不为“混合”时才计算这些
            sum_table = []
            unless sell_quote.quote_type == 2 || sell_quote.quote_type == 4#报价类型为“单项折扣”或“阶梯报价”则不写
              sum_table << [(sell_quote.language == 1) ? "总价：" : "Total EX-Works Price: ", sell_quote.currency.name + sprintf("%.2f",sell_quote.total)]
            end
            unless sell_quote.fif.blank?#运保费为空则不写
              sum_table << [(sell_quote.language == 1) ? "运保费：" : "Freight & Insurance Cost: ", sell_quote.fif_currency.name + sprintf("%.2f",sell_quote.fif)]
            end
            unless sell_quote.total_discount.blank?#折扣为空则不写
              sum_table << [(sell_quote.language == 1) ? "折扣：" : "Less Special Discount: ", sell_quote.fif_currency.name + sprintf("%.2f",sell_quote.total_discount)]
            end
            #sum_table << ["到货价：", sell_quote.currency.name.to_s + sell_quote.total.to_s]
            if(sell_quote.currency_id == 1)#只有报价币种为人民币的时候才折合，别的时候不管
              unless (sell_quote.quote_type == 2 || sell_quote.quote_type == 4)#报价类型为“单项折扣”或“阶梯报价”则不写
                sum_table << ["折合人民币：", "RMB" + sprintf("%.2f",sell_quote.total * sell_quote.currency.exchange_rate / 100)]
              end
            end
            unless sum_table.size == 0#有可能上面一项都没有，那么就彻底没有这栏
              table(sum_table,
                :column_widths => {0 => 570, 1 => 120},
                :cell_style => {:padding => 3}
              ) do |t|
                t.cells.style do |cell|
                  cell.borders -= [:top] unless cell.row == 0
                  cell.borders -= [:bottom] unless cell.row == sum_table.length - 1
                  cell.align = :right
                end
                t.column(0..1).style do |c|#两列右对齐
                  c.align = :right
                end
                t.column(0).style do |c|#左列无右框
                  c.borders -= [:right]
                end
                t.column(1).style do |c|#右列无左框
                  c.borders -= [:left]
                end
              end
            end
          end
        end

        move_down 25
        term0 = (sell_quote.language == 1) ? "<u>条款</u>" : "<u>NOTES</u>"
        text term0, :inline_format => true, :size => 14

        move_down 10
        list_item = 0#编号
        if term[1] != ""
          require "jcode"#汉字要截短
          if sell_quote.language == 1
            term1 = City.find(term[0]).name.to_s.scan(/./)[0..-2].join + price_type_array[term[1].to_i-1].to_s + "。"#截掉那个“市”字
            if term[22] == "true"#勾了“含税情况”才有，没勾就不管。英文的不会有此问题，不管。
              term1 += "以上价格" + receipt_array[term[23].to_i - 1].to_s + "。"
            end
          else
            term1 = price_type_array_en[term[1].to_i-1].to_s + " " + City.find(term[0]).en_name.to_s + "."
          end
          list_item += 1
          text "#{list_item}.　" + ((sell_quote.language == 1) ? "价格条款：" : "Terms of Price: ") + term1, :leading => 4
        end

        move_down 6
        term2 = ""
        if term[3] == "1"
          #信用证
          if sell_quote.language == 1
            term_money1 = (term[5].to_f.zero?)?(term[4] + "%"):("金额为" + pay_unit_array[term[5].to_i] + term[4] + "的")
            term2 += "签订合同后开立" + term_money1 + "即期不可撤销信用证，"
            if term[6] == "100" && term[7] == "0"
              #如果前面一个是100%，就没有“其余部分”了
              term2 += "100%见单即付。"
            else
              #不是100%，有“其余部分”
              term_money2 = (term[7].to_f.zero?)?(term[6] + "%"):(pay_unit_array[term[7].to_i] + term[6])
              term2 += "其中" + term_money2 + "见单即付，"
              term_money3 = (term[9].to_f.zero?)?(term[8] + "%"):(pay_unit_array[term[9].to_i] + term[8])
              term2 += "其余" + term_money3 + cad_left_via_array[term[10].to_i-1] + "。"
            end
          else
            ###############################################
            term_money1 = (term[5].to_f.zero?)?(term[4] + "% irrevocable L/C at sight"):("An irrevocable L/C at sight amount " + pay_unit_array[term[5].to_i] + term[4] + " ")
            term2 += term_money1 + "after signing the contract, "
            if term[6] == "100" && term[7] == "0"
              #如果前面一个是100%，就没有“其余部分”了
              term2 += " should be paid against the shipping documents. "
            else
              #不是100%，有“其余部分”
              term_money2 = (term[7].to_f.zero?)?(term[6] + "%"):(pay_unit_array[term[7].to_i] + term[6])
              term2 += term_money2 + " of the L/C value should be paid against the shipping documents, "
              term_money3 = (term[9].to_f.zero?)?(term[8] + "%"):(pay_unit_array[term[9].to_i] + term[8])
              term2 += term_money3 + " of the L/C value should be paid against " + cad_left_via_array_en[term[10].to_i-1] + ". "
            end
          end
        else
          #电汇
          if sell_quote.language == 1
            term_money1 = (term[5].to_f.zero?)?(term[4] + "%款项"):(pay_unit_array[term[5].to_i] + term[4])
            term2 += "签订合同后" + pay_time_array[term[2].to_i-1] + "天内电汇预付" + term_money1 + "。"
          else
            #############################################
            term_money1 = (term[5].to_f.zero?)?(term[4] + "%"):(pay_unit_array[term[5].to_i] + term[4])
            term2 += term_money1 + " T/T in advance within " + pay_time_array_en[term[2].to_i-1] + " days after signing the contract. "
          end
        end
        if term[11].blank? or term[12].blank? or term[12]=="0" or term[13].blank?
          #有一个没填就算没填
        else
          term_money3 = (term[13].to_f.zero?)?(term[12] + "%"):(pay_unit_array[term[13].to_i] + term[12])
          if sell_quote.language == 1
            term2 += "发货前" + pay_time_array[term[11].to_i-1] + "天内，电汇" + term_money3 + "款项。"
          else
            term2 += term_money3 + " T/T within " + pay_time_array_en[term[11].to_i-1] + " days before delivery. "
          end
        end
        if term[14].blank? or term[15].blank? or term[15]=="0" or term[16].blank?
          #有一个没填就算没填
        else
          term_money4 = (term[16].to_f.zero?)?(term[15] + "%"):(pay_unit_array[term[16].to_i] + term[15])
          if sell_quote.language == 1
            term2 += "发货后" + pay_time_array[term[14].to_i-1] + "天内，电汇" + term_money4 + "款项。"
          else
            term2 += term_money4 + " T/T within " + pay_time_array_en[term[14].to_i-1] + " days after delivery. "
          end
        end
        if term[17].blank? or term[18].blank? or term[18]=="0" or term[19].blank?
          #有一个没填就算没填
        else
          term_money5 = (term[19].to_f.zero?)?(term[18] + "%"):(pay_unit_array[term[19].to_i] + term[18])
          if sell_quote.language == 1
            term2 += "验收后" + pay_time_array[term[17].to_i-1] + "天内，电汇" + term_money5 + "款项。"
          else
            term2 += term_money5 + " T/T within " + pay_time_array_en[term[17].to_i-1] + " days after the acceptance at customer site. "
          end
        end
        if term[20].blank? or term[20]=="0" or term[21].blank?
          #有一个没填就算没填
        else
          term_money6 = ((term.to_f.zero?)?(term[20] + "%"):(pay_unit_array[term[21].to_i] + term[20]))
          term2 += term_money6 + (sell_quote.language == 1?"货款交货付现。":" COD. ")
        end

        list_item += 1
        text "#{list_item}.　" + ((sell_quote.language == 1) ? "付款方式：" : "Terms of Payment: ") + term2, :leading => 4

        if term[24] == "true" && (!term[26].blank? or !term[27].blank?)#勾了“交货期”，且两个日期都填了值才有，否则就不管
          temp = []
          if sell_quote.language == 1
            if term[26].blank? && !term[27].blank?
              t = term[27]
            elsif term[27].blank? && !term[26].blank?
              t = term[26]
            else
              t = term[26] + "至" + term[27]
            end
            term3 = delivery_point_array[term[25].to_i-1] + t + deliver_time_unit_array[term[28].to_i-1] + "内发货。"
            temp << "圣诞" if term[29] == "true"
            temp << "新年" if term[30] == "true"
            temp << "春节" if term[31] == "true"
            if temp.size > 0
              term3 += temp.join("、") + "假期不在其中。"
            end
          else
            if term[26].blank? && !term[27].blank?
              t = term[27]
            elsif term[27].blank? && !term[26].blank?
              t = term[26]
            else
              t = term[26] + "~" + term[27]
            end
            term3 = t + " " + deliver_time_unit_array_en[term[28].to_i-1] + " " + delivery_point_array_en[term[25].to_i-1] + ". "
            temp << "Christmas holiday" if term[29] == "true"
            temp << "Spring festival" if term[30] == "true"
            temp << "New year holiday" if term[31] == "true"
            if temp.size > 0
              term3 += "The delivery time does not include the " + temp.join("/") + "."
            end
          end

          move_down 6#因为上面行间距有了4，所以这里10就多了
          list_item += 1
          text "#{list_item}.　" + ((sell_quote.language == 1) ? "交货期：" : "Delivery if Schedule: ") + term3, :leading => 4
        end

        if term[32] == "true"#勾了“质量保证”才有，没勾就不管
          term4 = ""
          if sell_quote.language == 1
            term4 += warranty_point_array[term[33].to_i-1] + warranty_time_array[term[34].to_i-1] + "个月内质保。" unless term[33].blank?
            term4 += term[35] unless term[35].blank?
          else
            term4 += warranty_time_array[term[34].to_i-1] + " months "+ warranty_point_array_en[term[33].to_i-1] + ". " unless term[33].blank?
            term4 += term[35] unless term[35].blank?
          end

          move_down 6
          list_item += 1
          text "#{list_item}.　" + ((sell_quote.language == 1) ? "质量保证：" : "Warranty: ") + term4, :leading => 4
        end

        if term[36] == "true"#特别折扣
          if sell_quote.language == 1
            term5 = "此为给" + sell_quote.customer_unit.name + "的一次性特别折扣"
            term5 += "，此折扣有效期以工厂折扣结束时间为准" if term[37] == "true"#折扣有效期
            term5 += "。"
          else
            term5 = "This is one-time special discount to " + sell_quote.customer_unit.en_name + " only. "
            term5 += "This price is special promotion price, validates until the promotion period ending. " if term[37] == "true"#折扣有效期
          end

          move_down 6
          list_item += 1
          text "#{list_item}.　" + ((sell_quote.language == 1) ? "特别折扣：" : "Special discount: ") + term5, :leading => 4
        end

        move_down 6
        list_item += 1
        if sell_quote.language == 1
          text "#{list_item}.　报价有效期：本报价有效期至" + DateTime.parse(term[38]).strftime('%Y年%m月%d日').to_s + '。', :leading => 4
        else
          text "#{list_item}.　This quotation's validity expands until " + DateTime.parse(term[38]).strftime('%b %d, %Y').to_s + '.', :leading => 4
        end

        if !term[39].blank?
          #只有填了其它条款才有
          move_down 6
          list_item += 1
          text "#{list_item}.　"+ ((sell_quote.language == 1) ? "其它条款：" : "Other terms: ") + term[39], :leading => 4
        end


        #    以下就是“要生成的格式”
        #    1.  价格条款：武汉到货价。此价格不含税，如需开具发票，需收取相应发票税。/以上价格已含普通发票税（增值税）
        #    2.  付款方式：签订合同后15天内电汇预付30％款项，发货前15天内电汇支付30％款项，发货后15天内电汇支付30％款项，验收后15天内电汇支付10％款项
        #        （60%款项交货付现）
        #        （签订合同后开立100%即期不可撤销信用证，其中90%见单即付，10%验收合格后凭验收报告议付。）
        #        （签订合同后开立金额为USD3000的即期不可撤销信用证，其中90%见单即付，10%验收合格后凭验收报告议付。）
        #        （签订合同后开立90%的即期不可撤销信用证，100%见单即付。验收后15天内电汇10％款项。）
        #        （签订合同后开立90%的即期不可撤销信用证，100%见单即付。发货后30天内电汇10％款项。）
        #        （签订合同后开立90%的即期不可撤销信用证，其中90%见单即付，10%验收合格后凭验收报告议付。验收后6个月内电汇10％款项。）
        #    3.  交货期：收到预付款后 / 签订合同后 / 收到信用证后        周内发货。春节假期不在其中
        #    4.  质量保证：我方承诺自货物发出之日起 / 货物到港之日起 / 验收合格之日起1年内质保。
        #    5.  此价格为给 武汉光迅科技股份有限公司 的一次性特别折扣 / 此折扣有效期以工厂折扣结束时间为准
        #    6.  报价有效期：此报价有效期至2009年  月  日。
        #
        #    1.  Terms of Price: CIF Beijing.(Ex-works / FOB USA / DDU Wuhan / DDP Wuhan)
        #    2.  Terms of Payment: 30％T/T in advance within 15 days after signing the contract, 60％T/T within 15 days before delivery, 100％T/T within 15 days after delivery, 100％T/T within 15 days after the acceptance at customer site.(100% COD)  [T/T USD230 within 15 days]
        #    （100% Irrevocable L/C at sight, 90% of the contract value should be paid against the shipping documents; 10% of the contract value should be paid against the Certificate of Acceptance. ）
        #    （90% Irrevocable L/C at sight, should be paid against the shipping documents; 10％T/T within 15 days after the acceptance at customer site）
        #    （90% Irrevocable L/C at sight, should be paid against the shipping documents; 100％T/T within 15 days after delivery）
        #    （90% Irrevocable L/C at sight, 90% of the LC value should be paid against the shipping documents; 10% of the LC value should be paid against the Certificate of Acceptance. 10％T/T within 6 months after the acceptance at customer site. ）
        #    3.  Delivery if Schedule: 6-8 weeks after (receipt of the payment/ signing the contract / receipt of the L/C). The delivery time does not include the (Christmas holiday / Spring festival / New year holiday)
        #    4.  Warranty: 1 year after (shipping out the goods / the goods arrival at the destination / the acceptance)
        #    5.  This is one-time special discount to XX only.
        #    / This price is special promotion price, validates until the promotion period ending
        #    6.  This quotation’s validity expands until Dec 18, 2009.


        #          table([["foo", "bar " * 15, nil.to_s],
        #            ["baz", "bar", "foo " * 15]], :cell_style => { :padding => 12 }) do
        #            cells.borders = []
        #
        #            # Use the row() and style() methods to select and style a row.
        #            style row(0), :border_width => 2, :borders => [:bottom]
        #
        #            # The style method can take a block, allowing you to customize properties
        #            # per-cell.
        #            style(columns(0..1)) { |cell| cell.borders |= [:right] }
        #          end
        #
        #          move_down 12
        #
        #          table([%w[foo bar bazbaz], %w[baz bar foofoo]],
        #            :cell_style => { :padding => 12 }, :width => bounds.width)
      end
      #全部完成后，如果报价没有完成时间，则完成时间设成当前时间
      if sell_quote.work_task.completed_on.nil?
        sell_quote.work_task.completed_on = DateTime.now
        sell_quote.work_task.last_user_id = session[:user_id]
        sell_quote.work_task.save
      end
      #报价的状态可以改了，目前定为改成2吧
      sell_quote.flow_status = 2
      sell_quote.save
      render :text => {"str" => "OK", "number" => sell_quote.quote_number}.to_json
    end
  end

  #生成报价相关的摘要的JSON，以供做合同选择报价时下拉提示
  def get_summary
    respond_to do |format|
      format.json {
        summary = gen_summary
        render :text => summary
      }
    end
  end

  def gen_summary
    summary_array = []
    #    para
    #    quotes = SellQuote.find(:all, :conditions => ["sale_user_id = ?", session[:user_id]])#只选自己让做的报价？
    #    quotes = SellQuote.find(:all, :conditions => ["sale_user_id = ? and customer_id = ?", session[:user_id], params[:id]])
    quotes = SellQuote.where("sale_user_id = ? and customer_id = ?", session[:user_id], params[:id])#只选自己让做的、客户为当前目标客户的报价？
    for quote in quotes
      summary_array << {
        "id" => quote.id,
        "summary" => quote.quote_number + "(" + quote.customer.name + "@" + quote.created_at.strftime("%Y-%m-%d") + ")"
      }
    end
    return summary_array.to_json
    #    products = Product.find(:all, :conditions => ["model like ?", "%"+params[:query].split("(")[0]+"%"])#解析时不带工厂名
    #    for product in products
    #      model_array << {
    #        "model" => product.model+"("+product.producer.name+")",
    #        "id" => product.id
    #      }
    #    end
    #    return model_array.to_json
  end

  #TODO 先把新增那里灰掉，先从后面加一个看看，以后有空再做新增(因为有输入单位名称下拉这样的麻烦事)

  def ext_paginate
    #响应分页事件
    respond_to do |format|
      format.json {
        sell_quote_json = gen_sell_quote_paginate_json(params[:start].to_i,params[:limit],params[:sort],params[:dir],params[:keyword])
        render :text => sell_quote_json.to_json
      }
    end
  end

  def gen_sell_quote_paginate_json(start, limit ,keyword, sort="id", dir="DESC")
    #生成合同列表的分页JSON
    sell_quote_json=[]
    #有些字段可能在数据库里为空，但显示出来会有问题，所以不能要
    not_null_field = %w(quote_number)
    origin_conditions = not_null_field.map{|p| "sell_quotes."+p+" is not null"}.join(" or ")#因为会有无效数据，所以先限定一下使之在列表里不显示……
    origin_conditions += " and sell_quotes.customer_unit_id is not null"
    if keyword.blank?
      #没有关键字
      total_records = SellQuote.where(*origin_conditions)
      sell_quotes = SellQuote.where(*origin_conditions).order(sort).limit(limit).offset(start.to_i)
    else
      #先把关键字按空格切分，全角半角都算，取前五个
      keywords = keyword.split("　").join(" ").split(" ")[0..4]
      #如果关键字中有一个“+”，则按and来计算，否则就算or
      if keywords.index("+")
        joint = "and"
        keywords = keywords-["+"]
      else
        joint = "or"
      end
      #参与查找的字段
      columns = %w(summary customer_number)
      fore_conditions_keyword = []#按关键字再循环后的数组
      back_conditions = []
      #先对关键字循环
      for i_keyword in keywords
        #再对字段循环
        fore_conditions_column = []#按字段循环后的数组
        for column in columns
          fore_conditions_column << "sell_quotes."+column+" like ?"#这里需要注意，带“表名”，为避免多表里有重名字段要特别标记之
          back_conditions << "%"+ i_keyword +"%"
        end
        #以下是跨表字段，单独写
        #        fore_conditions_column << "customer_units.name like ?"
        #        back_conditions << "%"+keyword+"%"
        #        fore_conditions_column << "customers.name like ?"
        #        back_conditions << "%"+keyword+"%"
        #        fore_conditions_column << "pop_units.name like ?"
        #        back_conditions << "%"+keyword+"%"
        #        fore_conditions_column << "pops.name like ?"
        #        back_conditions << "%"+keyword+"%"

        fore_condition_column = "(" + fore_conditions_column.join(" or ") + ")"#这一层全是or，因为是针对每个字段
        fore_conditions_keyword << fore_condition_column
      end
      fore_condition = fore_conditions_keyword.join(" "+joint+" ") + " and (" + origin_conditions + ")"
      conditions = fore_condition.to_a + back_conditions
      #跨表查询，include后面带的是“模型”里“belongs_to”或者“has_many”的那个东东
#      total_records = SellQuote.find(:all, :conditions => conditions)#, :include => [{:equiper => {:customer_unit => :customers}},:pop, :pop_unit])
#      sell_quotes = SellQuote.find(:all,
#        :order => "sell_quotes."+sort+" "+dir,#这里也有重名字段问题，所以一定要写前面的表名
#        :conditions => conditions,
#        :limit => limit,
#        :offset => start#,
#        #        :include => [{:equiper => {:customer_unit => :customers}},:pop, :pop_unit]
#      )
      total_records = SellQuote.where(*conditions)#, :include => [{:equiper => {:customer_unit => :customers}},:pop, :pop_unit])
      sell_quotes = SellQuote.where(*conditions).order(sort).limit(limit).offset(start.to_i)
    end
    if sell_quotes.size > 0
      for sell_quote in sell_quotes
        if sell_quote.customer_unit.blank?
          customer_unit_id = nil
          customer_unit_name = "待定"
        else
          customer_unit_id = sell_quote.customer_unit.id
          customer_unit_name = sell_quote.customer_unit.name
        end
        if sell_quote.customer.blank?
          customer_id = nil
          customer_name = "待定"
        else
          customer_id = sell_quote.customer.id
          customer_name = sell_quote.customer.name
        end
        sell_quote_json << {"quote_number" => sell_quote.quote_number.blank? ? "未完成" : sell_quote.quote_number,
          "customer_unit_id" =>  customer_unit_id,
          "customer_unit_name" => customer_unit_name,
          "customer_id" =>  customer_id,
          "customer_name" => customer_name,
          "sale" => sell_quote.sponsor.nil? ? "待定" : sell_quote.sponsor.real_name,
          "total" => sell_quote.currency.blank? ? "待定" : sell_quote.currency.name+sell_quote.total.to_s,
          #        "customer_equiper" => sell_quote.equiper.name,
          #        "customer_buyer" => sell_quote.buyer.name,
          #        "pop" => sell_quote.pop.blank? ? "待定" : sell_quote.pop.pop_unit.name + sell_quote.pop.name,
          "id" => sell_quote.id
        }
      end
    end
    #有关键字，总记录数取查找结果
    {"totalRecords" => total_records.size.to_s, "data" => sell_quote_json}
    #    end
  end

  def download_quotation(dummy=nil)
    send_file("#{Rails.root}/public/files/quotation/#{params[:id]}.pdf",:disposition => "attachment")
  end

  def view_quotation(dummy=nil)
    send_file("#{Rails.root}/public/files/quotation/#{params[:id]}.pdf",:disposition => "inline")
  end

  #以下是计算当前最高的关税项
  def get_max_custom_tax(sell_quote)
    #计算方法：如果报价块有关税，则忽略其下报价项关税，把此关税加到参与计算的数组中；否则对报价块中报价项循环，把各报价项的关税加到参与计算的数组中。最后在数组中取max
    custom_tax_array = []
    for sqb in sell_quote.sell_quote_blocks
      if sqb.custom_tax.blank?
        for sqi in sqb.sell_quote_items
          custom_tax_array << sqi.custom_tax.to_f
        end
      else
        custom_tax_array << sqb.custom_tax.to_f
      end
    end
    return custom_tax_array.max
  end

  def restful
    if request.get?
      #查
      respond_to do |format|
        format.json {
          if params[:sort].nil?
            #如果没有在表格里排序，则没有参数传回来，不管，就相当于用默认的ID降序排
            sell_quote_json = gen_sell_quote_paginate_json(params[:start],params[:limit],params[:keyword])#,params[:sort],params[:dir])
          else
            #如果表格里有排序，会传过来类似"[{\"property\":\"mobile\",\"direction\":\"ASC\"}]"的参数
            sort_param_hash = JSON.parse(params[:sort])
            sort = sort_param_hash[0]["property"]
            dir = sort_param_hash[0]["direction"]
            sell_quote_json = gen_sell_quote_paginate_json(params[:start],params[:limit],params[:keyword],sort,dir)
          end
          render :text => sell_quote_json.to_json
        }
      end
    else
    end
  end

  #列出指定id报价下所有报价项的属性，给summary table用
  def get_sell_quote_items
    respond_to do |format|
      format.json {
        sell_quote_item_list = gen_sell_quote_items
        render :text => sell_quote_item_list.to_json
      }
    end
  end

  def gen_sell_quote_items(dummy = nil)
    detail_array = []
    params["id"] = "11" if params["id"] == "0"#临时用一下
    sell_quote = SellQuote.find(params[:id])
    case sell_quote.quote_type
    when 1
    when 2
    when 3
      #系统报价的话，要看报价块
      sell_quote_blocks = sell_quote.sell_quote_blocks
      sell_quote_blocks.each_with_index do |sqb, index_b|
        if !(sqb.sell_quote.term.nil?) && sqb.sell_quote.term.split("$$")[42] == "true"
          #当term不为空时，才会有后面的是否勾选“在报价中计算关税”
          #二者都成立的时候，直接读数据库。
          discount_to = sqb.discount_to.to_s
          unit_price = sqb.unit_price.to_s
        else
          #如果没有勾“在报价中计算关税”，则再看报价块有没有默认的折后单价
          if sqb.unit_price_after_discount.nil?
            #如果没有，那么报价块单价=计算报价块下所有报价项折后总价之和
            unit_price = 0
            sqb.sell_quote_items.each do |sqi|
              unit_price += sqi.discount_to
            end
            discount_to = (unit_price * sqb.quantity).to_s
            unit_price = unit_price.to_s
          else
            #如果有，那么就用它
            discount_to = (sqb.unit_price_after_discount * sqb.quantity).to_s
            unit_price = sqb.unit_price_after_discount.to_s
          end
        end
        detail_array << eval("{'hidden_id' => '"+sqb.id.to_s+#本来这里是用id的，结果上下两处的“id”会起冲突……
          "', 'product_model' => '" + sqb.description.to_s +
            "', 'parameter' => '" + sqb.parameter.to_s +
            "', 'quantity' => '" + sqb.quantity.to_s +
            "', 'currency' => '" + ((sqb.currency.nil? || sqb.currency_id == 0)? "待定": sqb.currency.name)+
            "', 'unit_price' => '" + unit_price +
            "', 'unit_price_after_discount' => '" + sqb.unit_price_after_discount.to_s +
            "', 'discounted_currency' => '" + ((sqb.currency.nil? || sqb.currency_id == 0)? "待定": sqb.currency.name)+
            "', 'custom_tax' => '" + sqb.custom_tax.to_s +
            "', 'discount_rate' => '" + sqb.discount_rate.to_s +
            "', 'discount_to' => '" + discount_to.to_s +
            "', 'is_sys' => '" + pre_add_zero(index_b+1,2).to_s +
            "', 'currency_id' => '" + ((sqb.currency.nil? || sqb.currency_id == 0)? "待定": sqb.currency.id.to_s)+
            "'}")
        sell_quote_items = sqb.sell_quote_items
        #每个报价块中的报价项
        sell_quote_items.each_with_index do |sqi, index_i|
          discount_to = sqi.discount_to.to_s
          detail_array << eval("{'hidden_id' => '"+sqi.id.to_s+#本来这里是用id的，结果上下两处的“id”会起冲突……
            "', 'product_model' => '" + sqi.product.model+
              "', 'parameter' => '" + sqi.parameter+
              "', 'quantity' => '" + sqi.product_quantity.to_s+
              "', 'currency' => '" + sqi.product.currency.name+
              "', 'unit_price' => '" + sqi.unit_price.to_s+
              "', 'unit_price_after_discount' => '" + sqi.unit_price_after_discount.to_s +
              "', 'discounted_currency' => '" + ((sqi.discounted_currency_id.nil?)? "待定": sqi.discounted_currency.name)+
              "', 'custom_tax' => '" + sqi.product.custom_tax.to_s+
              "', 'discount_rate' => '" + sqi.discount_rate.to_s+
              "', 'discount_to' => '" + discount_to.to_s +
              "', 'is_sys' => '" + pre_add_zero(index_b+1,2).to_s+"-"+pre_add_zero(index_i+1,3).to_s +
              "', 'currency_id' => '" + sqi.product.currency.id.to_s+
              "'}")
        end
      end
    end
    return detail_array
  end
end
